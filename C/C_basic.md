## 《C语言进阶》 ilearning课程
- const 主要看const在*的左侧还是右侧  
  const int* p1; // p1指向的const变量不能更改，const在*左侧  
  int const *p2; // p2指向的const变量不能更改，const在*左侧，只是写法不同

  int* const p3; // p3常量指针，指向固定的一个地址，const在*右侧  
  const int *const p4; // 常量指针，指向的const内容都不能更改



- 不同的数据模型（操作系统或者配置），int，long占用的字节不一致。
例如：  
(ILP32)32bit Linux: sizeof(int) == sizeof(long) == sizeof(char*) == 4  
(LP64)64bit Linux: sizeof(long) == sizeof(char*) == 8

- 浮点数据类型float,double是不能用unsigned修饰的。

- gdb调试时linux必备技能，特别对于大型软件问题定位，需要用-g编译选项，然后确保自己有gdb。


- 测试对于软件开发重要性很高，对于重构需要短平快的方式实现快速迭代，及时验证。

- 测试用例的学习，
- 1.了解熟悉全面的测试场景，个个测试用例都是浓缩的精华。测试用例是可以简单执行和验证和精简化自动化脚本。可以极大减少人为误判的可能性，减少重复性劳动，同时测试用例都是精心设计或者根据以往累计问题总结出的血的教训。
- 2.开发与测试交互联系的途径，开发无法避免的坎。测试和开发脱钩，将导致一系列隐含问题，如果开发学会了所有测试用例，就可以轻松躲避测试拦截，从而不会出现测试回归不通过的问题。对于问题定位自验证和后续代码重构，测试用例的设计将成为开发的必修课，不知道代码实现目标，期望结果，何谈问题彻底解决，怎么确保自己重构代码没有引入问题。
- 3.测试用例的共同迭代完善是测试和代码开发标准化的必要过程。为什么以往现网问题无法拦截？总是低概率复现？为什么开发要接口这么多问题？如果将所有测试用例归一，不仅在开发自验证，整机IV测试，产品测试过程中，将会极大提高定位问题和拦截问题的能力。所以要扪心自问，问题的触发条件都清楚了吗？能够简化成自动化用例吗？问题重复度这么高，能不能用一起策划一套问题check脚本检查基本状况是否正常。然后后续问题的定位解决先上自动化脚本，错在哪些基本条件的缺失，比如CMU版本不对，sdr版本不对，这是故障模式库和问题定位QA的最终交付件。
- 4.手动化测试将会逐步被淘汰，全自动测试用例要渐渐取代手动测试。经历过低概率问题复现的同事都清楚其痛苦性，但是即使解决了一个问题，后面再出现这种场景，还是走在漫漫复现路上，也不能做到举一反三的效果。对于压力场景，如何加大报文量，这些测试项没有通用的测试用例。